## 1. Введение: что такое LZ77 и зачем он нужен?

**LZ77** (алгоритм Лемпела-Зива, 1977) — это фундаментальный алгоритм сжатия данных **без потерь**, основанный на идее поиска и замены повторяющихся фрагментов в потоке данных. Вместо явного кодирования повторяющихся последовательностей алгоритм заменяет их **ссылками** на предыдущие вхождения тех же данных.

**Где применяется:**

- Входит в основу популярных форматов: ZIP, gzip, PNG
    
- Эффективен для текстов, логов, исходного кода
    
- Комбинируется с энтропийным кодированием (Хаффмана, арифметическим) в алгоритме DEFLATE
    

## 2. Ключевые концепции и принцип работы

### 2.1 Принцип скользящего окна 

Алгоритм использует концепцию "скользящего окна" — буфера, который содержит последние обработанные данные. Кодер и декодер поддерживают одинаковые окна, что позволяет заменять повторяющиеся последовательности ссылками на уже "увиденные" данные.

### 2.2 Механизм кодирования совпадений

Вместо кодирования символов напрямую, LZ77 ищет максимальное совпадение текущей подстроки с данными в скользящем окне и кодирует его компактной ссылкой.

## 3. Структура данных и форматы токенов

### Параметры алгоритма:

- **W (Window Size)** — размер окна поиска (например, 32 КБ)
    
- **L (Lookahead Buffer)** — максимальная длина совпадающей подстроки
    

### Формат токенов:

LZ77 генерирует токены двух типов:

1. **Литерал** (для новых символов):

    (0, 0, char)
    
    - Используется, когда совпадение не найдено
        
    - `char` — непосредственно символ для добавления
        
2. **Ссылка** (для совпадений):
    
    (offset, length, next_symbol)
    
    - `offset` — расстояние назад до начала совпадающей подстроки
        
    - `length` — количество совпавших символов
        
    - `next_symbol` — первый символ после совпадения (для продвижения по потоку)
        

## 4. Псевдокод алгоритма

### Кодирование:

```python
function LZ77_encode(input, W, L):
    pos = 0
    output = []
    
    while pos < input.length:
        best_offset = 0
        best_length = 0
        
        # Поиск в скользящем окне
        window_start = max(0, pos - W)
        for i from window_start to pos - 1:
            length = 0
            # Поиск максимального совпадения
            while (length < L and 
                   pos + length < input.length and 
                   input[i + length] == input[pos + length]):
                length += 1
            
            # Сохранение лучшего совпадения
            if length > best_length:
                best_length = length
                best_offset = pos - i
        
        # Формирование токена
        if best_length == 0:
            # Нет совпадения — литерал
            output.append((0, 0, input[pos]))
            pos += 1
        else:
            # Есть совпадение — ссылка
            next_char = input[pos + best_length] if (pos + best_length < input.length) else EOF
            output.append((best_offset, best_length, next_char))
            pos += best_length + 1
    
    return output

```


### Декодирование:

```python
function LZ77_decode(tokens):
    output = []
    for token in tokens:
        offset, length, next_symbol = token
        
        if offset == 0 and length == 0:
            # Литерал
            output.append(next_symbol)
        else:
            # Копирование по ссылке
            start = len(output) - offset
            for k in range(length):
                output.append(output[start + k])
            
            # Добавление следующего символа
            if next_symbol != EOF:
                output.append(next_symbol)
    
    return output
```


## 5. Примеры работы алгоритма

### Пример 1: Строка "ABABABA"

**Параметры:** W = 4, L = 6

**Процесс кодирования:**

|Шаг|Текущая позиция|Окно|Действие|Токен|
|---|---|---|---|---|
|1|**A**BABABA|`[]`|Нет совпадения|`(0, 0, 'A')`|
|2|A **B**ABABA|`[A]`|Нет совпадения|`(0, 0, 'B')`|
|3|AB **ABABA**|`[A,B]`|Совпадение: "ABAB" (offset=2, length=4)|`(2, 4, 'A')`|

**Результат:** `[(0,0,'A'), (0,0,'B'), (2,4,'A')]`

**Декодирование:**

1. `(0,0,'A')` → `"A"`
    
2. `(0,0,'B')` → `"AB"`
    
3. `(2,4,'A')` → копируем 4 символа, начиная с позиции len("AB")-2=0 → "ABAB" + 'A' → `"ABABABA"`
    

### Пример 2: Классический пример "abracadabra"

|Шаг|Текущая позиция|Найденное совпадение|Токен|
|---|---|---|---|
|1|**a**bracadabra|Нет|`(0, 0, 'a')`|
|2|a **b**racadabra|Нет|`(0, 0, 'b')`|
|3|ab **r**acadabra|Нет|`(0, 0, 'r')`|
|4|abr **a**cadabra|'a' (offset=3, length=1)|`(3, 1, 'c')`|
|5|abrac **ad**abra|"a" (offset=2, length=1)|`(2, 1, 'd')`|
|6|abracad **abra**|"abra" (offset=7, length=4)|`(7, 4, EOF)`|

**Результат:** `[(0,0,'a'), (0,0,'b'), (0,0,'r'), (3,1,'c'), (2,1,'d'), (7,4,EOF)]`

## 6. Преимущества и недостатки

### Преимущества:

- Простая концепция и реализация
    
- Хорошо сжимает данные с повторяющимися паттернами
    
- Не требует предварительной обработки данных
    

### Недостатки наивной реализации:

- **Высокая сложность** — O(n×W×L) 
    
- **Ограничения словаря** — нельзя ссылаться на данные за пределами окна


## 7. Оптимизации поиска

Для практического использования LZ77 требуются оптимизации поиска совпадений:

### 1. Хеш-таблицы

```python

# Быстрый поиск кандидатов по префиксу
hash_table = {}  # hash -> list of positions
current_hash = hash(input[pos:pos+3])  # хеш первых 3 символов
# Проверяем только позиции с таким же хешом, а не все окно
```

### 2. Бинарные деревья поиска

- Суффиксные деревья
    
- Суффиксные массивы
    
- Позволяют находить совпадения за O(log n)
    

### 3. Ограничение глубины поиска

- Проверка только первых N кандидатов из хеш-цепи
    
- Компромисс между скоростью и качеством сжатия
    

### 4. Эвристики

- Прекращение поиска при достижении достаточно длинного совпадения
    
- Приоритет ближайших совпадений (меньший offset → меньше бит на кодирование)
    

## 8. Развитие алгоритма

LZ77 породил семейство алгоритмов с улучшениями:

### LZSS (Storer-Szymanski, 1982)

- Убирает обязательный `next_symbol`
    
- Вводит флаговые биты для различения литералов и ссылок
    
- Более эффективное кодирование
    

### DEFLATE (Phil Katz, 1990-е)

- Комбинация LZ77 + кодирование Хаффмана
    
- Используется в ZIP, gzip, PNG
    

### LZMA (7-Zip)

- Улучшенный алгоритм с более сложными эвристиками
    
- Использует контекстное моделирование и арифметическое кодирование
    

## 9. Практическое применение

- **ZIP/GZIP** — DEFLATE = LZ77 + Хаффман
    
- **PNG** — DEFLATE для сжатия строк разности
    
- **HTTP сжатие** — gzip/deflate
    
- **СУБД** — сжатие страниц данных
    
- **Файловые системы** — прозрачное сжатие
    
## 10. Алгоритм Deflate

Deflate - алгоритм сжатия без потерь, использующий комбинацию алгоритмов LZ77 и Хаффмана. Работает в два этапа:

### Этап 1: LZ77 (удаление повторений)

- **Поиск совпадений**: алгоритм ищет повторяющиеся строки в данных
    
- **Замена на пары (длина, расстояние)**:
    
    - `длина` - сколько символов совпало (3-258 байт)
        
    - `расстояние` - насколько далеко назад находится начало совпадения (1-32768 байт)
        
- **Пример**: строка `"abcabc"` → `"abc" + (длина=3, расстояние=3)`
    

### Этап 2: Кодирование Хаффмана (статистическое сжатие)

- **Частотный анализ**: подсчет частоты встречаемости символов
    
- **Построение дерева**: частые символы → короткие коды, редкие → длинные
    
- **Два типа символов**:
    
    1. **Литералы** (0-255) - обычные байты
        
    2. **Длины/расстояния** (257-285, 0-29) - ссылки LZ77
        

### Формат Deflate-блока

```
[Заголовок: 3 бита]
  - бит 0: 1=последний блок, 0=есть еще
  - биты 1-2: тип сжатия:
    00 = без сжатия
    01 = статический Хаффман
    10 = динамический Хаффман (наиболее частый)
    11 = ошибка
[Данные блока]
```
### Особенности Deflate

- **Динамические таблицы Хаффмана** (тип 10):
    
    - Таблицы оптимизируются для каждого блока
        
    - Передаются вместе с данными
        
- **Статические таблицы** (тип 01):
    
    - Фиксированные таблицы для типичных текстов
        
    - Не нужно передавать таблицы
        
- **Без сжатия** (тип 00):
    
    - Когда сжатие неэффективно
        

### Преимущества Deflate

1. **Высокое сжатие** - комбинация LZ77 и Хаффмана дает синергию
    
2. **Быстрая декомпрессия** - особенно со статическими таблицами
    
3. **Свобода от патентов** - в отличие от LZW (используемого в GIF)
    
4. **Адаптивность** - динамический Хаффман подстраивается под данные
    

### Где используется

- **ZIP** - основной алгоритм архивации
    
- **PNG** - сжатие данных изображения
    
- **gzip** - утилита и формат сжатия
    
- **HTTP** - сжатие web-контента
    
- **Git** - сжатие объектов
    

### Пример работы

```
Исходные данные: "the cat in the hat"
LZ77: "the cat in " + (длина=4, расстояние=11) + "hat"
Коды Хаффмана: 't'=00, 'h'=01, 'e'=100, ' '=101, ...
Результат: битовая последовательность кодов

Deflate обеспечивает оптимальный баланс между степенью сжатия, скоростью работы и вычислительной сложностью, что объясняет его широкое применение.
```





